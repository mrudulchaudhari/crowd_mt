{% extends "core/base.html" %}
{% block title %}Event ‚Äî {{ event.name }}{% endblock %}

{% block content %}
  <section class="event-wrap">
    <div class="card event-card--detail">
      <div class="event-header">
        <div>
          <h2 id="event-title">{{ event.name }}</h2>
          <p class="muted" id="event-location">
            {% if event.location %}üìç {{ event.location }}{% else %}Location not specified{% endif %}
          </p>
        </div>

        <div class="meta">
          <span class="badge" id="event-status">Loading‚Ä¶</span>
        </div>
      </div>

      <div class="thresholds">
        <h4>Thresholds</h4>
        <p class="muted">
          Safety threshold:
          <strong id="safety-thr">{% if event.safety_threshold %}{{ event.safety_threshold }}{% else %}‚Äî{% endif %}</strong>
          &nbsp;‚Ä¢&nbsp;
          Crowded threshold:
          <strong id="crowded-thr">{% if event.crowded_threshold %}{{ event.crowded_threshold }}{% else %}‚Äî{% endif %}</strong>
        </p>
        <p class="muted">Thresholds configured: <strong id="threshold-configured">{% if event.safety_threshold or event.crowded_threshold %}Yes{% else %}No{% endif %}</strong></p>
      </div>

      <div class="headcount-block">
        <h3 class="small">Current headcount</h3>
        <div id="headcount" class="headcount">Loading‚Ä¶</div>
        <div class="headcount-meta">
          <small>Last updated: <span id="last-updated">‚Äî</span></small>
        </div>
      </div>

      <div class="actions">
        <a class="btn btn-secondary" href="{% url 'core_templates:events_list' %}">‚Üê Back to events</a>
        <a class="btn btn-primary" id="refresh-btn" role="button">Refresh now</a>
      </div>
    </div>

    <div class="card">
      <h4>About this event</h4>
      <p class="muted">
        Event ID: <code>{{ event.id }}</code> ‚Ä¢ Starts: {{ event.start_time|default:"‚Äî" }} ‚Ä¢ Ends: {{ event.end_time|default:"‚Äî" }}
      </p>
      {% if event.description %}
      <p>{{ event.description }}</p>
      {% else %}
      <p class="muted">No description available.</p>
      {% endif %}
    </div>
  </section>
{% endblock %}


{% block scripts %}
<script>
  const EVENT_ID = {{ event.id }};
  const API_URL = `/api/events/${EVENT_ID}/`;
  const STATUS_URL = `/api/status/?event_id=${EVENT_ID}`;
  const WS_URL_BASE = (location.protocol === 'https:' ? 'wss:' : 'ws:') + '//' + location.host;

  const headcountEl = document.getElementById('headcount');
  const lastUpdatedEl = document.getElementById('last-updated');
  const eventTitleEl = document.getElementById('event-title');
  const refreshBtn = document.getElementById('refresh-btn');

  const statusBadge = document.getElementById('event-status');
  const safetyThrEl = document.getElementById('safety-thr');
  const crowdedThrEl = document.getElementById('crowded-thr');
  const thrConfiguredEl = document.getElementById('threshold-configured');

  let currentCount = null;
  let ws = null;
  let wsConnected = false;

  function setBadge(text, level) {
    // level: 'ok' | 'warning' | 'critical' | 'loading' | 'disconnected' | 'live'
    statusBadge.innerText = text;
    statusBadge.className = 'badge'; // reset
    if (level === 'ok') statusBadge.classList.add('badge--ok');
    else if (level === 'warning') statusBadge.classList.add('badge--warn');
    else if (level === 'critical') statusBadge.classList.add('badge--crit');
    else if (level === 'live') statusBadge.classList.add('badge--live');
    else if (level === 'disconnected') statusBadge.classList.add('badge--disc');
    else statusBadge.classList.add('badge--muted');
  }

  function flashElement(el) {
    el.classList.add('pulse');
    setTimeout(() => el.classList.remove('pulse'), 600);
  }

  async function fetchStatus() {
    try {
      const r = await fetch(STATUS_URL, { credentials: 'same-origin' });
      if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
      const data = await r.json();
      // expected fields: headcount, status, predicted_next_hour, timestamp
      applyStatusData(data);
    } catch (err) {
      // fallback to event GET
      console.warn('status fetch failed, falling back to event GET', err);
      await fetchEventOnce(); // will call renderEventData
    }
  }

  async function fetchEventOnce() {
    try {
      const resp = await fetch(API_URL, { credentials: 'same-origin' });
      if (!resp.ok) throw new Error(`${resp.status} ${resp.statusText}`);
      const data = await resp.json();
      // update thresholds UI if available from event object
      if (data.safety_threshold !== undefined) {
        safetyThrEl.innerText = data.safety_threshold ?? '‚Äî';
      }
      if (data.crowded_threshold !== undefined) {
        crowdedThrEl.innerText = data.crowded_threshold ?? '‚Äî';
      }
      thrConfiguredEl.innerText = (data.safety_threshold || data.crowded_threshold) ? 'Yes' : 'No';
      renderEventData(data);
    } catch (err) {
      headcountEl.innerHTML = `<span style="color:var(--danger)">${err.message}</span>`;
    }
  }

  function applyStatusData(data) {
    if (!data) return;
    // set counts
    const last = data.headcount ?? null;
    if (last !== null) {
      headcountEl.innerText = last;
      currentCount = typeof last === 'number' ? last : currentCount;
    }
    // set last-updated
    const ts = data.timestamp ? new Date(data.timestamp) : new Date();
    lastUpdatedEl.innerText = ts.toLocaleString();

    // update thresholds shown if included
    // some status responses may not include thresholds, so keep existing DOM values otherwise

    // prefer `data.status` if provided by serializer
    const statusText = data.status ?? computeStatusTextFromCounts(last);
    const level = mapStatusToLevel(statusText, last);
    setBadge(statusText, level);
  }

  function computeStatusTextFromCounts(count) {
    // fallback local compute if status endpoint isn't available
    const safety = parseInt(safetyThrEl.innerText) || null;
    const crowded = parseInt(crowdedThrEl.innerText) || null;
    if (count === null || count === 'N/A') return 'Unknown';
    if (crowded && count >= crowded) return 'Critical';
    if (safety && count > safety) return 'Warning';
    return 'OK';
  }

  function mapStatusToLevel(statusText, count) {
    const s = (statusText || '').toString().toLowerCase();
    if (s.includes('critical') || s.includes('capacity') || s.includes('danger')) return 'critical';
    if (s.includes('warning') || s.includes('near') || s.includes('warning')) return 'warning';
    if (s.includes('live')) return 'live';
    if (s.includes('disconnected')) return 'disconnected';
    return 'ok';
  }

  function renderEventData(data) {
    if (!data) return;
    if (data.name) eventTitleEl.innerText = data.name;

    const newCount = (data.current_headcount === null || data.current_headcount === undefined) ? 'N/A' : data.current_headcount;

    // animate/flash if changed and numeric
    if (typeof currentCount === 'number' && typeof newCount === 'number' && newCount !== currentCount) {
      flashElement(headcountEl);
    }
    currentCount = (typeof newCount === 'number') ? newCount : newCount;
    headcountEl.innerText = currentCount;

    // update thresholds if included
    if (data.safety_threshold !== undefined) {
      safetyThrEl.innerText = data.safety_threshold ?? '‚Äî';
    }
    if (data.crowded_threshold !== undefined) {
      crowdedThrEl.innerText = data.crowded_threshold ?? '‚Äî';
    }
    thrConfiguredEl.innerText = (data.safety_threshold || data.crowded_threshold) ? 'Yes' : 'No';

    // decide badge based on server-provided status if available
    if (data.status) {
      const level = mapStatusToLevel(data.status, currentCount);
      setBadge(data.status, level);
    } else {
      // local compute
      const txt = computeStatusTextFromCounts(currentCount);
      const level = mapStatusToLevel(txt, currentCount);
      setBadge(txt, level);
    }

    lastUpdatedEl.innerText = new Date().toLocaleString();
  }

  // Polling fallback (every 6s)
  let pollInterval = null;
  function startPolling() {
    if (pollInterval) return;
    pollInterval = setInterval(fetchStatus, 6000);
  }
  function stopPolling() {
    if (pollInterval) {
      clearInterval(pollInterval);
      pollInterval = null;
    }
  }

  // WebSocket live updates: listens for headcount_update or event_update
  function tryWebSocket() {
    try {
      ws = new WebSocket(`${WS_URL_BASE}/ws/event/${EVENT_ID}/`);
      ws.addEventListener('open', () => {
        wsConnected = true;
        stopPolling();
        setBadge('Live', 'live');
      });
      ws.addEventListener('message', (ev) => {
        try {
          const payload = JSON.parse(ev.data);
          // handle different message types you broadcast from server
          if (payload.type === 'headcount_update' && payload.data) {
            // payload.data: {headcount, timestamp, source, event_id}
            const d = payload.data;
            applyStatusData({ headcount: d.headcount, timestamp: d.timestamp, status: null });
          } else if (payload.type === 'event_update') {
            // payload: {headcount, status}
            applyStatusData({ headcount: payload.headcount, status: payload.status, timestamp: new Date().toISOString() });
          } else if (payload.type === 'alert_message' && payload.data) {
            // optionally show alerts in the UI (toast, etc.)
            console.info('Alert:', payload.data);
            // For critical alerts, show badge
            setBadge('Critical', 'critical');
          } else {
            // fallback: if server sends full event object
            if (payload.current_headcount !== undefined) {
              renderEventData(payload);
            }
          }
        } catch (e) {
          console.warn('WS parse error', e);
        }
      });
      ws.addEventListener('close', () => {
        wsConnected = false;
        setBadge('Disconnected', 'disconnected');
        startPolling();
        setTimeout(tryWebSocket, 5000);
      });
      ws.addEventListener('error', (err) => {
        console.warn('WS error', err);
        if (ws) ws.close();
      });
    } catch (err) {
      console.warn('WebSocket unavailable', err);
      startPolling();
    }
  }

  // Manual refresh
  refreshBtn.addEventListener('click', () => {
    fetchStatus();
    flashElement(refreshBtn);
  });

  document.addEventListener('DOMContentLoaded', () => {
    // initial fetch from status endpoint (preferred)
    fetchStatus();
    // attempt websocket; polling will start if ws fails
    tryWebSocket();
    setTimeout(() => { if (!wsConnected) startPolling(); }, 800);
  });

  // cleanup
  window.addEventListener('beforeunload', () => {
    if (ws) ws.close();
  });
</script>

<style>
  /* Scoped styles for event detail */
  .event-wrap { max-width: 900px; margin: 0 auto; display: grid; gap: 1.25rem; }

  .event-header { display: flex; justify-content: space-between; align-items: flex-start; gap: 1rem; }
  .event-header h2 { margin-bottom: 0.25rem; font-size: 1.4rem; }
  .muted { color: #64748b; font-size: 0.95rem; }

  .meta { display:flex; align-items:center; gap:0.5rem; }
  .badge { padding: 0.35rem 0.6rem; border-radius: 999px; font-weight: 700; font-size: 0.85rem; }
  .badge--ok { background:#e6fffa; color:#065f46; }
  .badge--warn { background:#fff7ed; color:#92400e; }
  .badge--crit { background:#ffeef0; color:#9b1c1c; }
  .badge--live { background:#e8f3ff; color:#0f172a; }
  .badge--disc { background:#f1f5f9; color:#475569; }
  .badge--muted { background:#eef2ff; color:#334155; }

  .thresholds h4 { margin-top: 0.6rem; margin-bottom: 0.2rem; }
  .headcount-block { margin-top: 1rem; }
  .headcount { font-size: 3rem; font-weight: 700; margin: .4rem 0; color: #0f172a; }
  .headcount-meta small { color: #64748b; }

  .actions { display:flex; gap: .75rem; margin-top: 1.25rem; }

  .pulse { animation: pulse-change 0.6s ease; }
  @keyframes pulse-change {
    0% { transform: scale(1); background: rgba(34,197,94,0); }
    30% { transform: scale(1.06); background: rgba(34,197,94,0.12); }
    100% { transform: scale(1); background: transparent; }
  }

  code { background: #f1f5f9; padding: 0.15rem .35rem; border-radius: 6px; }
  #refresh-btn.pulse { transform: translateY(-1px); }
</style>
{% endblock %}
