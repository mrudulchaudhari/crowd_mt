{% extends "core/base.html" %}
{% block title %}Event ‚Äî {{ event.name }}{% endblock %}

{% block content %}
  <section class="event-wrap">
    <div class="card event-card--detail">
      <div class="event-header">
        <div>
          <h2 id="event-title">{{ event.name }}</h2>
          <p class="muted" id="event-location">
            {% if event.location %}üìç {{ event.location }}{% else %}Location not specified{% endif %}
          </p>
        </div>

        <div class="meta">
          <span class="badge" id="event-status">Loading‚Ä¶</span>
        </div>
      </div>

      <div class="thresholds">
        <h4>Thresholds</h4>
        <p class="muted">
          Safety threshold:
          <strong id="safety-thr">{% if event.safety_threshold %}{{ event.safety_threshold }}{% else %}‚Äî{% endif %}</strong>
          &nbsp;‚Ä¢&nbsp;
          Crowded threshold:
          <strong id="crowded-thr">{% if event.crowded_threshold %}{{ event.crowded_threshold }}{% else %}‚Äî{% endif %}</strong>
        </p>
        <p class="muted">Thresholds configured: <strong id="threshold-configured">{% if event.safety_threshold or event.crowded_threshold %}Yes{% else %}No{% endif %}</strong></p>
      </div>

      <div class="headcount-block">
        <h3 class="small">Current headcount</h3>
        <div id="headcount" class="headcount">Loading‚Ä¶</div>
        <div class="headcount-meta">
          <small>Last updated: <span id="last-updated">‚Äî</span></small>
        </div>
      </div>

      <div class="actions">
        <a class="btn btn-secondary" href="{% url 'core_templates:events_list' %}">‚Üê Back to events</a>
        <a class="btn btn-primary" id="refresh-btn" role="button">Refresh now</a>
      </div>
    </div>

    <div class="card">
      <h4>About this event</h4>
      <p class="muted">
        Event ID: <code>{{ event.id }}</code> ‚Ä¢ Starts: {{ event.start_time|default:"‚Äî" }} ‚Ä¢ Ends: {{ event.end_time|default:"‚Äî" }}
      </p>
      {% if event.description %}
      <p>{{ event.description }}</p>
      {% else %}
      <p class="muted">No description available.</p>
      {% endif %}
    </div>
  </section>
{% endblock %}


{% block scripts %}
<script>
  const EVENT_ID = {{ event.id }};
  const API_URL = `/api/events/${EVENT_ID}/`;
  const STATUS_URL = `/api/status/?event_id=${EVENT_ID}`;
  const WS_URL_BASE = (location.protocol === 'https:' ? 'wss:' : 'ws:') + '//' + location.host;

  const headcountEl = document.getElementById('headcount');
  const lastUpdatedEl = document.getElementById('last-updated');
  const eventTitleEl = document.getElementById('event-title');
  const refreshBtn = document.getElementById('refresh-btn');

  const statusBadge = document.getElementById('event-status');
  const safetyThrEl = document.getElementById('safety-thr');
  const crowdedThrEl = document.getElementById('crowded-thr');
  const thrConfiguredEl = document.getElementById('threshold-configured');

  let currentCount = null;
  let ws = null;
  let wsConnected = false;

  // Helper: remove any badge--* classes then add the one we want
  function setBadge(text, level) {
    statusBadge.innerText = text;
    // remove previous level classes
    statusBadge.classList.remove('badge--ok','badge--warn','badge--crit','badge--live','badge--disc','badge--muted');
    // always keep base 'badge' class
    statusBadge.classList.add('badge');
    if (level === 'ok') statusBadge.classList.add('badge--ok');
    else if (level === 'warning') statusBadge.classList.add('badge--warn');
    else if (level === 'critical') statusBadge.classList.add('badge--crit');
    else if (level === 'live') statusBadge.classList.add('badge--live');
    else if (level === 'disconnected') statusBadge.classList.add('badge--disc');
    else statusBadge.classList.add('badge--muted');
  }

  function flashElement(el) {
    el.classList.add('pulse');
    setTimeout(() => el.classList.remove('pulse'), 600);
  }

  // Parse text to integer safely; returns null if not a valid number
  function toIntSafe(v) {
    if (v === null || v === undefined) return null;
    const n = Number(String(v).replace(/[^\d\-]/g, '')); // strip non-digits (keeps minus)
    return Number.isFinite(n) ? n : null;
  }

  // Compute status locally given numeric counts & thresholds
  function computeStatusTextFromCounts(count) {
    const safety = toIntSafe(safetyThrEl.innerText);
    const crowded = toIntSafe(crowdedThrEl.innerText);

    if (count === null || count === undefined || count === 'N/A') return 'Unknown';
    const cnum = toIntSafe(count);
    if (cnum === null) return 'Unknown';

    // priority: critical (>= crowded), warning (> safety), ok otherwise
    if (crowded !== null && cnum >= crowded) return 'Critical';
    if (safety !== null && cnum > safety) return 'Warning';
    return 'OK';
  }

  function mapStatusToLevel(statusText) {
    const s = (statusText || '').toString().toLowerCase();
    if (s.includes('critical') || s.includes('capacity') || s.includes('danger')) return 'critical';
    if (s.includes('warning') || s.includes('near')) return 'warning';
    if (s.includes('live')) return 'live';
    if (s.includes('disconnected')) return 'disconnected';
    return 'ok';
  }

  function applyStatusData(data) {
    if (!data) return;
    const last = data.headcount ?? null;
    if (last !== null) {
      headcountEl.innerText = last;
      currentCount = toIntSafe(last) ?? currentCount;
    }

    // timestamps
    const ts = data.timestamp ? new Date(data.timestamp) : new Date();
    lastUpdatedEl.innerText = ts.toLocaleString();

    // prefer server status if provided; otherwise compute locally
    const statusText = data.status ?? computeStatusTextFromCounts(last);
    const level = mapStatusToLevel(statusText);
    setBadge(statusText, level);
  }

  async function fetchStatus() {
    try {
      const r = await fetch(STATUS_URL, { credentials: 'same-origin' });
      if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
      const data = await r.json();
      // update thresholds display if API returns them inside the event/status payload
      if (data.safety_threshold !== undefined) safetyThrEl.innerText = data.safety_threshold ?? '‚Äî';
      if (data.crowded_threshold !== undefined) crowdedThrEl.innerText = data.crowded_threshold ?? '‚Äî';
      thrConfiguredEl.innerText = (toIntSafe(safetyThrEl.innerText) || toIntSafe(crowdedThrEl.innerText)) ? 'Yes' : 'No';
      applyStatusData(data);
    } catch (err) {
      console.warn('status fetch failed, falling back to event GET', err);
      await fetchEventOnce();
    }
  }

  async function fetchEventOnce() {
    try {
      const resp = await fetch(API_URL, { credentials: 'same-origin' });
      if (!resp.ok) throw new Error(`${resp.status} ${resp.statusText}`);
      const data = await resp.json();
      // update thresholds UI
      if (data.safety_threshold !== undefined) safetyThrEl.innerText = data.safety_threshold ?? '‚Äî';
      if (data.crowded_threshold !== undefined) crowdedThrEl.innerText = data.crowded_threshold ?? '‚Äî';
      thrConfiguredEl.innerText = (toIntSafe(safetyThrEl.innerText) || toIntSafe(crowdedThrEl.innerText)) ? 'Yes' : 'No';
      applyStatusData({ headcount: data.current_headcount ?? data.current_headcount, status: data.status, timestamp: new Date().toISOString() });
    } catch (err) {
      headcountEl.innerHTML = `<span style="color:var(--danger)">${err.message}</span>`;
    }
  }

  // Polling fallback
  let pollInterval = null;
  function startPolling() { if (pollInterval) return; pollInterval = setInterval(fetchStatus, 6000); }
  function stopPolling() { if (pollInterval) { clearInterval(pollInterval); pollInterval = null; } }

  // WebSocket live updates (listens for headcount_update / event_update)
  function tryWebSocket() {
    try {
      ws = new WebSocket(`${WS_URL_BASE}/ws/event/${EVENT_ID}/`);
      ws.addEventListener('open', () => {
        wsConnected = true;
        stopPolling();
        setBadge('Live', 'live');
      });
      ws.addEventListener('message', (ev) => {
        try {
          const payload = JSON.parse(ev.data);
          if (payload.type === 'headcount_update' && payload.data) {
            const d = payload.data;
            // payload.data: {headcount, timestamp, source, event_id}
            applyStatusData({ headcount: d.headcount, timestamp: d.timestamp, status: null });
          } else if (payload.type === 'event_update') {
            applyStatusData({ headcount: payload.headcount, status: payload.status, timestamp: new Date().toISOString() });
          } else if (payload.type === 'alert_message' && payload.data) {
            // critical alert ‚Äî prefer showing critical
            setBadge('Critical', 'critical');
            console.info('Alert:', payload.data);
          } else {
            if (payload.current_headcount !== undefined) {
              applyStatusData({ headcount: payload.current_headcount, timestamp: payload.timestamp ?? new Date().toISOString() });
            }
          }
        } catch (e) {
          console.warn('WS parse error', e);
        }
      });
      ws.addEventListener('close', () => {
        wsConnected = false;
        setBadge('Disconnected', 'disconnected');
        startPolling();
        setTimeout(tryWebSocket, 5000);
      });
      ws.addEventListener('error', (err) => {
        console.warn('WS error', err);
        if (ws) ws.close();
      });
    } catch (err) {
      console.warn('WebSocket unavailable', err);
      startPolling();
    }
  }

  // Manual refresh
  refreshBtn.addEventListener('click', () => { fetchStatus(); flashElement(refreshBtn); });

  document.addEventListener('DOMContentLoaded', () => {
    fetchStatus();
    tryWebSocket();
    setTimeout(() => { if (!wsConnected) startPolling(); }, 800);
  });

  // cleanup
  window.addEventListener('beforeunload', () => { if (ws) ws.close(); });
</script>


<style>
  /* Scoped styles for event detail */
  .event-wrap { max-width: 900px; margin: 0 auto; display: grid; gap: 1.25rem; }

  .event-header { display: flex; justify-content: space-between; align-items: flex-start; gap: 1rem; }
  .event-header h2 { margin-bottom: 0.25rem; font-size: 1.4rem; }
  .muted { color: #64748b; font-size: 0.95rem; }

  .meta { display:flex; align-items:center; gap:0.5rem; }
  .badge { padding: 0.35rem 0.6rem; border-radius: 999px; font-weight: 700; font-size: 0.85rem; }
  .badge--ok { background:#e6fffa; color:#065f46; }
  .badge--warn { background:#fff7ed; color:#92400e; }
  .badge--crit { background:#ffeef0; color:#9b1c1c; }
  .badge--live { background:#e8f3ff; color:#0f172a; }
  .badge--disc { background:#f1f5f9; color:#475569; }
  .badge--muted { background:#eef2ff; color:#334155; }

  .thresholds h4 { margin-top: 0.6rem; margin-bottom: 0.2rem; }
  .headcount-block { margin-top: 1rem; }
  .headcount { font-size: 3rem; font-weight: 700; margin: .4rem 0; color: #0f172a; }
  .headcount-meta small { color: #64748b; }

  .actions { display:flex; gap: .75rem; margin-top: 1.25rem; }

  .pulse { animation: pulse-change 0.6s ease; }
  @keyframes pulse-change {
    0% { transform: scale(1); background: rgba(34,197,94,0); }
    30% { transform: scale(1.06); background: rgba(34,197,94,0.12); }
    100% { transform: scale(1); background: transparent; }
  }

  code { background: #f1f5f9; padding: 0.15rem .35rem; border-radius: 6px; }
  #refresh-btn.pulse { transform: translateY(-1px); }
</style>
{% endblock %}
